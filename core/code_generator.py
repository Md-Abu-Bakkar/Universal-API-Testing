"""
Code Generator - Generate bot-ready code from API results
"""

import json
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
import os

logger = logging.getLogger(__name__)

class CodeGenerator:
    def __init__(self, config=None):
        self.config = config or {}
        self.templates = self._load_templates()
    
    def generate_python_code(self, api_results: List[Dict[str, Any]], 
                           template_type: str = "requests") -> str:
        """
        Generate Python code from API results
        
        Args:
            api_results: List of API testing results
            template_type: Type of template ("requests" or "aiohttp")
            
        Returns:
            str: Generated Python code
        """
        logger.info(f"Generating Python code using {template_type} template")
        
        if template_type == "aiohttp":
            return self._generate_aiohttp_code(api_results)
        else:
            return self._generate_requests_code(api_results)
    
    def generate_curl_commands(self, api_results: List[Dict[str, Any]]) -> List[str]:
        """
        Generate cURL commands from API results
        
        Args:
            api_results: List of API testing results
            
        Returns:
            list: List of cURL commands
        """
        curl_commands = []
        
        for result in api_results:
            if result.get('success', False):
                curl_cmd = self._generate_single_curl(result)
                if curl_cmd:
                    curl_commands.append(curl_cmd)
        
        return curl_commands
    
    def generate_bot_template(self, api_results: List[Dict[str, Any]], 
                            bot_name: str = "APIBot") -> str:
        """
        Generate complete bot template
        
        Args:
            api_results: List of API testing results
            bot_name: Name for the bot class
            
        Returns:
            str: Complete bot template code
        """
        successful_apis = [r for r in api_results if r.get('success', False)]
        
        if not successful_apis:
            return "# No successful APIs found to generate bot template"
        
        template = self.templates.get('bot_template', '')
        
        # Replace placeholders
        template = template.replace('{{bot_name}}', bot_name)
        template = template.replace('{{generation_date}}', datetime.now().isoformat())
        template = template.replace('{{total_apis}}', str(len(successful_apis)))
        
        # Generate API methods
        api_methods = []
        for i, api in enumerate(successful_apis):
            method_name = self._generate_method_name(api)
            method_code = self._generate_api_method(api, method_name)
            api_methods.append(method_code)
        
        template = template.replace('{{api_methods}}', '\n\n'.join(api_methods))
        
        return template
    
    def export_code(self, code: str, filename: str, output_dir: str = None) -> bool:
        """
        Export generated code to file
        
        Args:
            code: Generated code
            filename: Output filename
            output_dir: Output directory (uses config if None)
            
        Returns:
            bool: True if successful
        """
        try:
            if output_dir is None:
                output_dir = self.config.get('export', {}).get('default_output_dir', './exports')
            
            os.makedirs(output_dir, exist_ok=True)
            
            filepath = os.path.join(output_dir, filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(code)
            
            logger.info(f"Exported code to {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Error exporting code: {e}")
            return False
    
    def _generate_requests_code(self, api_results: List[Dict[str, Any]]) -> str:
        """Generate code using requests library"""
        imports = [
            "import requests",
            "import json",
            "import time",
            "from typing import Dict, Any, Optional"
        ]
        
        code_lines = [
            "# Generated by Universal API Tester",
            f"# Date: {datetime.now().isoformat()}",
            "# Template: requests",
            ""
        ]
        
        # Add imports
        code_lines.extend(imports)
        code_lines.extend(["", ""])
        
        # Add session setup
        code_lines.extend([
            "class APIClient:",
            "    def __init__(self):",
            "        self.session = requests.Session()",
            "        self.base_headers = {",
            "            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',",
            "            'Accept': 'application/json, text/plain, */*'",
            "        }",
            "        self.session.headers.update(self.base_headers)",
            ""
        ])
        
        # Generate methods for each successful API
        successful_apis = [r for r in api_results if r.get('success', False)]
        
        for i, api in enumerate(successful_apis):
            method_name = self._generate_method_name(api)
            method_code = self._generate_requests_method(api, method_name)
            code_lines.extend(method_code)
            code_lines.append("")
        
        # Add main execution block
        code_lines.extend([
            "if __name__ == '__main__':",
            "    client = APIClient()",
            "    print('API Client initialized')",
            ""
        ])
        
        return '\n'.join(code_lines)
    
    def _generate_aiohttp_code(self, api_results: List[Dict[str, Any]]) -> str:
        """Generate code using aiohttp library"""
        imports = [
            "import aiohttp",
            "import asyncio",
            "import json",
            "from typing import Dict, Any, Optional"
        ]
        
        code_lines = [
            "# Generated by Universal API Tester",
            f"# Date: {datetime.now().isoformat()}",
            "# Template: aiohttp",
            ""
        ]
        
        # Add imports
        code_lines.extend(imports)
        code_lines.extend(["", ""])
        
        # Add class definition
        code_lines.extend([
            "class AsyncAPIClient:",
            "    def __init__(self):",
            "        self.session = None",
            "        self.base_headers = {",
            "            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',",
            "            'Accept': 'application/json, text/plain, */*'",
            "        }",
            "",
            "    async def __aenter__(self):",
            "        self.session = aiohttp.ClientSession(headers=self.base_headers)",
            "        return self",
            "",
            "    async def __aexit__(self, exc_type, exc_val, exc_tb):",
            "        await self.session.close()",
            ""
        ])
        
        # Generate methods for each successful API
        successful_apis = [r for r in api_results if r.get('success', False)]
        
        for i, api in enumerate(successful_apis):
            method_name = self._generate_method_name(api)
            method_code = self._generate_aiohttp_method(api, method_name)
            code_lines.extend(method_code)
            code_lines.append("")
        
        # Add main execution block
        code_lines.extend([
            "async def main():",
            "    async with AsyncAPIClient() as client:",
            "        print('Async API Client initialized')",
            "        # Add your API calls here",
            "",
            "if __name__ == '__main__':",
            "    asyncio.run(main())",
            ""
        ])
        
        return '\n'.join(code_lines)
    
    def _generate_requests_method(self, api: Dict[str, Any], method_name: str) -> List[str]:
        """Generate a single method using requests"""
        method_lines = [
            f"    def {method_name}(self, **kwargs):",
            f"        \"\"\"",
            f"        API: {api.get('api', 'Unknown')}",
            f"        Type: {api.get('type', 'UNKNOWN')}",
            f"        Method: {api.get('method', 'GET')}",
            f"        \"\"\"",
            "        try:",
        ]
        
        url = api.get('api', '')
        method = api.get('method', 'GET').lower()
        
        # Prepare request parameters
        if method == 'get':
            method_lines.append(f"            response = self.session.get('{url}', **kwargs)")
        elif method == 'post':
            method_lines.append(f"            response = self.session.post('{url}', **kwargs)")
        else:
            method_lines.append(f"            response = self.session.request('{method.upper()}', '{url}', **kwargs)")
        
        # Add response handling
        method_lines.extend([
            "            response.raise_for_status()",
            "            return {",
            "                'success': True,",
            "                'status_code': response.status_code,",
            "                'data': response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text",
            "            }",
            "        except Exception as e:",
            "            return {",
            "                'success': False,",
            "                'error': str(e),",
            "                'status_code': getattr(e, 'response', None).status_code if hasattr(e, 'response') else None",
            "            }"
        ])
        
        return method_lines
    
    def _generate_aiohttp_method(self, api: Dict[str, Any], method_name: str) -> List[str]:
        """Generate a single method using aiohttp"""
        method_lines = [
            f"    async def {method_name}(self, **kwargs):",
            f"        \"\"\"",
            f"        API: {api.get('api', 'Unknown')}",
            f"        Type: {api.get('type', 'UNKNOWN')}",
            f"        Method: {api.get('method', 'GET')}",
            f"        \"\"\"",
            "        try:",
        ]
        
        url = api.get('api', '')
        method = api.get('method', 'GET').upper()
        
        method_lines.append(f"            async with self.session.{method.lower()}('{url}', **kwargs) as response:")
        method_lines.extend([
            "                response.raise_for_status()",
            "                content_type = response.headers.get('content-type', '')",
            "                if 'application/json' in content_type:",
            "                    data = await response.json()",
            "                else:",
            "                    data = await response.text()",
            "                return {",
            "                    'success': True,",
            "                    'status_code': response.status,",
            "                    'data': data",
            "                }",
            "        except Exception as e:",
            "            return {",
            "                'success': False,",
            "                'error': str(e)",
            "            }"
        ])
        
        return method_lines
    
    def _generate_single_curl(self, api: Dict[str, Any]) -> str:
        """Generate a single cURL command"""
        url = api.get('api', '')
        method = api.get('method', 'GET')
        
        curl_parts = [f"curl -X {method.upper()}"]
        
        # Add headers
        headers = api.get('headers', {})
        for key, value in headers.items():
            if key.lower() not in ['content-length', 'host']:
                curl_parts.append(f"  -H '{key}: {value}'")
        
        # Add URL
        curl_parts.append(f"  '{url}'")
        
        return ' \\\n'.join(curl_parts)
    
    def _generate_method_name(self, api: Dict[str, Any]) -> str:
        """Generate a method name from API information"""
        url = api.get('api', '')
        api_type = api.get('type', 'UNKNOWN').lower()
        
        # Extract meaningful parts from URL
        parts = url.split('/')
        meaningful_parts = [p for p in parts if p and not p.startswith('http') and '.' not in p]
        
        if meaningful_parts:
            last_part = meaningful_parts[-1]
            # Clean up the part
            method_name = re.sub(r'[^a-zA-Z0-9]', '_', last_part)
            method_name = re.sub(r'_+', '_', method_name).strip('_')
        else:
            method_name = f"api_{api_type}"
        
        # Ensure it starts with a letter
        if not method_name[0].isalpha():
            method_name = f"api_{method_name}"
        
        return method_name
    
    def _generate_api_method(self, api: Dict[str, Any], method_name: str) -> str:
        """Generate a complete API method"""
        url = api.get('api', '')
        method = api.get('method', 'GET')
        
        return f'''    def {method_name}(self):
        """
        Call {url}
        Method: {method}
        """
        # Implement API call here
        pass'''
    
    def _load_templates(self) -> Dict[str, str]:
        """Load code templates"""
        templates = {
            'bot_template': '''# Auto-generated Bot Template
# Generated: {{generation_date}}
# Total APIs: {{total_apis}}

import requests
import json
import time
from typing import Dict, Any, Optional

class {{bot_name}}:
    def __init__(self):
        self.session = requests.Session()
        self.base_url = "YOUR_BASE_URL_HERE"
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
            'Accept': 'application/json, text/plain, */*'
        })
    
    def login(self, username: str, password: str) -> bool:
        """
        Implement login logic here
        """
        # Add your login implementation
        return True

{{api_methods}}

if __name__ == '__main__':
    bot = {{bot_name}}()
    print("Bot initialized successfully")'''
        }
        
        return templates
